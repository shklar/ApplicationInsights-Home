using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Mail;
using System.Runtime.Remoting.Messaging;
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.Extensibility;
using Microsoft.WindowsAzure.ServiceRuntime;
using Microsoft.WindowsAzure.Storage.Blob;
using Microsoft.WindowsAzure.Storage.Queue;
using Microsoft.WindowsAzure.Storage.Table;
using MvcWebRole.Models;
using SendGridMail;
using WorkerRoleB.Telemetry;

namespace WorkerRoleB
{
    public class WorkerRoleB : RoleEntryPoint
    {
        private CloudQueue sendEmailQueue;
        private CloudQueue subscribeQueue;
        private CloudBlobContainer blobContainer;
        private CloudTable mailingListTable;
        private CloudTable messageTable;
        private CloudTable messagearchiveTable;
        private volatile bool onStopCalled = false;
        private volatile bool returnedFromRunMethod = false;

        private TelemetryClient aiClient = new TelemetryClient();
        private static string CORRELATION_SLOT = "CORRELATION-ID";
        public override void Run()
        {
            CloudQueueMessage msg = null;
            Trace.TraceInformation("WorkerRoleB start of Run()");
            while (true)
            {
                try
                {
                    var loopStart = DateTimeOffset.UtcNow;
                    bool messageFound = false;

                    // If OnStop has been called, return to do a graceful shutdown.
                    if (onStopCalled == true)
                    {
                        Trace.TraceInformation("onStopCalled WorkerRoleB");
                        returnedFromRunMethod = true;
                        return;
                    }
                    // Retrieve and process a new message from the send-email-to-list queue.
                    msg = sendEmailQueue.GetMessage();
                    if (msg != null)
                    {
                        ProcessQueueMessage(msg);
                        messageFound = true;
                    }

                    // Retrieve and process a new message from the subscribe queue.
                    msg = subscribeQueue.GetMessage();
                    if (msg != null)
                    {
                        ProcessSubscribeQueueMessage(msg);
                        messageFound = true;
                    }
                    
                    if (messageFound == false)
                    {
                        System.Threading.Thread.Sleep(1000 * 30);
                    }
                    else
                    {
                        aiClient.TrackMetric("LoopWithMessagesTimeMs", ((TimeSpan)(DateTimeOffset.Now - loopStart)).Milliseconds);
                    }
                }
                catch (Exception ex)
                {
                    string err = ex.Message;
                    if (ex.InnerException != null)
                    {
                        err += " Inner Exception: " + ex.InnerException.Message;
                    }
                    if (msg != null)
                    {
                        err += " Last queue message retrieved: " + msg.AsString;
                    }
                    Trace.TraceError(err, ex);                    
                }
            }
        }

        private int GetRoleInstance()
        {
            string instanceId = RoleEnvironment.CurrentRoleInstance.Id;
            int instanceIndex = -3;
            int.TryParse(instanceId.Substring(instanceId.LastIndexOf("_") + 1), out instanceIndex);

            // The instanceIndex of the first instance is 0. 
            return instanceIndex;
        }

        private void ProcessQueueMessage(CloudQueueMessage msg)
        {
            Stopwatch requestTimer = Stopwatch.StartNew();
            var request = RequestTelemetryHelper.StartNewRequest("ProcessEmailQueueMessage", DateTimeOffset.UtcNow);
            CallContext.LogicalSetData(CORRELATION_SLOT, request.Id);
            //Thread.SetData(Thread.GetNamedDataSlot(CORRELATION_SLOT), request.Id);
            try
            {
                // Log and delete if this is a "poison" queue message (repeatedly processed
                // and always causes an error that prevents processing from completing).
                // Production applications should move the "poison" message to a "dead message"
                // queue for analysis rather than deleting the message.           
                if (msg.DequeueCount > 5)
                {
                    Trace.TraceError("Deleting poison message:    message {0} Role Instance {1}.",
                        msg.ToString(), GetRoleInstance());
                    sendEmailQueue.DeleteMessage(msg);
                    request.Properties.Add(new KeyValuePair<string,string>("FailureCode","PoisonMessage"));
                    request.Properties.Add(new KeyValuePair<string, string>("DequeueCount", msg.DequeueCount.ToString()));
                    if (msg.InsertionTime != null)
                    {
                        request.Metrics.Add(new KeyValuePair<string, double>("EmailProcessingTimeMs", ((TimeSpan)(DateTimeOffset.Now - msg.InsertionTime)).Milliseconds));
                    }
                    RequestTelemetryHelper.DispatchRequest(request, requestTimer.Elapsed, false);
                    return;
                }
                // Parse message retrieved from queue.
                // Example:  2012-01-01,0123456789email@domain.com,0
                var messageParts = msg.AsString.Split(new char[] { ',' });
                var partitionKey = messageParts[0];
                var rowKey = messageParts[1];
                var restartFlag = messageParts[2];
                Trace.TraceInformation("ProcessQueueMessage start:  partitionKey {0} rowKey {1} Role Instance {2}.", partitionKey, rowKey, GetRoleInstance());
                // If this is a restart, verify that the email hasn't already been sent.
                if (restartFlag == "1")
                {
                    var retrieveOperationForRestart = TableOperation.Retrieve<SendEmail>(partitionKey, rowKey);
                    var retrievedResultForRestart = messagearchiveTable.Execute(retrieveOperationForRestart);
                    var messagearchiveRow = retrievedResultForRestart.Result as SendEmail;
                    if (messagearchiveRow != null)
                    {
                        // SendEmail row is in archive, so email is already sent. 
                        // If there's a SendEmail Row in message table, delete it,
                        // and delete the queue message.
                        Trace.TraceInformation("Email already sent: partitionKey=" + partitionKey + " rowKey= " + rowKey);
                        var deleteOperation = TableOperation.Delete(new SendEmail { PartitionKey = partitionKey, RowKey = rowKey, ETag = "*" });
                        try
                        {
                            messageTable.Execute(deleteOperation);
                        }
                        catch(Exception ex)
                        {
                            aiClient.TrackException(ex);
                        }
                        sendEmailQueue.DeleteMessage(msg);
                        request.Properties.Add(new KeyValuePair<string, string>("SuccessCode", "NoOp-MessageAlreadySent"));
                        if (msg.InsertionTime != null)
                        {
                            request.Metrics.Add(new KeyValuePair<string, double>("EmailProcessingTimeMs", ((TimeSpan)(DateTimeOffset.Now - msg.InsertionTime)).Milliseconds));
                        }
                        RequestTelemetryHelper.DispatchRequest(request, requestTimer.Elapsed, true);
                        return;
                    }
                }
                // Get the row in the Message table that has data we need to send the email.
                var retrieveOperation = TableOperation.Retrieve<SendEmail>(partitionKey, rowKey);
                var retrievedResult = messageTable.Execute(retrieveOperation);
                var emailRowInMessageTable = retrievedResult.Result as SendEmail;
                if (emailRowInMessageTable == null)
                {
                    Trace.TraceError("SendEmail row not found:  partitionKey {0} rowKey {1} Role Instance {2}.",partitionKey, rowKey, GetRoleInstance());
                    request.Properties.Add(new KeyValuePair<string, string>("FailureCode", "SendEmailRowNotFound"));
                    if (msg.InsertionTime != null)
                    {
                        request.Metrics.Add(new KeyValuePair<string, double>("EmailProcessingTimeMs", ((TimeSpan)(DateTimeOffset.Now - msg.InsertionTime)).Milliseconds));
                    }
                    RequestTelemetryHelper.DispatchRequest(request, requestTimer.Elapsed, false);
                    return;
                }
                // Derive blob names from the MessageRef.
                var htmlMessageBodyRef = emailRowInMessageTable.MessageRef + ".htm";
                var textMessageBodyRef = emailRowInMessageTable.MessageRef + ".txt";
                // If the email hasn't already been sent, send email and archive the table row.
                if (emailRowInMessageTable.EmailSent != true)
                {
                    SendEmailToList(emailRowInMessageTable, htmlMessageBodyRef, textMessageBodyRef);

                    var emailRowToDelete = new SendEmail { PartitionKey = partitionKey, RowKey = rowKey, ETag = "*" };
                    emailRowInMessageTable.EmailSent = true;

                    var upsertOperation = TableOperation.InsertOrReplace(emailRowInMessageTable);
                    messagearchiveTable.Execute(upsertOperation);
                    var deleteOperation = TableOperation.Delete(emailRowToDelete);
                    messageTable.Execute(deleteOperation);
                }

                // Delete the queue message.
                sendEmailQueue.DeleteMessage(msg);
                Trace.TraceInformation("ProcessQueueMessage complete:  partitionKey {0} rowKey {1} Role Instance {2}.", partitionKey, rowKey, GetRoleInstance());
                request.Properties.Add(new KeyValuePair<string, string>("SuccessCode", "EmailSent"));
                if (msg.InsertionTime != null)
                {
                    request.Metrics.Add(new KeyValuePair<string, double>("EmailProcessingTimeMs", ((TimeSpan)(DateTimeOffset.Now - msg.InsertionTime)).Milliseconds));
                }
                RequestTelemetryHelper.DispatchRequest(request, requestTimer.Elapsed, true);
            }
            catch (Exception ex)
            {
                request.Properties.Add(new KeyValuePair<string, string>("FailureCode", "Exception"));
                if (msg.InsertionTime != null)
                {
                    request.Metrics.Add(new KeyValuePair<string, double>("FailedEmailProcessingTimeMs", ((TimeSpan)(DateTimeOffset.Now - msg.InsertionTime)).Milliseconds));
                }
                RequestTelemetryHelper.DispatchRequest(request, requestTimer.Elapsed, false);
                throw ex;
            }            
        }

        private void SendEmailToList(SendEmail emailRowInMessageTable, string htmlMessageBodyRef, string textMessageBodyRef)
        {
            var email = SendGrid.GetInstance();
            email.From = new MailAddress(emailRowInMessageTable.FromEmailAddress);
            email.AddTo(emailRowInMessageTable.EmailAddress);
            email.Html = GetBlobText(htmlMessageBodyRef) + GetHTMLUnsubscribeLink(emailRowInMessageTable);
            email.Text = GetBlobText(textMessageBodyRef) + GetPlainTextUnsubscribeLink(emailRowInMessageTable);
            email.Subject = emailRowInMessageTable.SubjectLine;
            var credentials = new NetworkCredential(RoleEnvironment.GetConfigurationSettingValue("SendGridUserName"),
                RoleEnvironment.GetConfigurationSettingValue("SendGridPassword"));
            var transportREST = Web.GetInstance(credentials);
            transportREST.Deliver(email);
        }
        
        private string GetBlobText(string blogRef)
        {
            var blob = blobContainer.GetBlockBlobReference(blogRef);
            blob.FetchAttributes();
            var blobSize = blob.Properties.Length;
            using (var memoryStream = new MemoryStream((int)blobSize))
            {
                blob.DownloadToStream(memoryStream);
                return System.Text.Encoding.UTF8.GetString(memoryStream.ToArray());
            }
        }

        private string GetHTMLUnsubscribeLink(SendEmail emailRowInMessageTable)
        {
            return String.Format("<p>Click the following link to unsubscribe. <a href=\"{0}/unsubscribe?id={1}&listName={2}\">Unsubscribe</a></p>",
                RoleEnvironment.GetConfigurationSettingValue("AzureMailServiceURL"),
                emailRowInMessageTable.SubscriberGUID,
                emailRowInMessageTable.ListName);
        }

        private string GetPlainTextUnsubscribeLink(SendEmail emailRowInMessageTable)
        {
            return String.Format("\nCopy the following URL into your browser unsubscribe.\n{0}/unsubscribe?id={1}&listName={2}",
                RoleEnvironment.GetConfigurationSettingValue("AzureMailServiceURL"),
                emailRowInMessageTable.SubscriberGUID,
                emailRowInMessageTable.ListName);
        }

        private void ProcessSubscribeQueueMessage(CloudQueueMessage msg)
        {
            Stopwatch requestTimer = Stopwatch.StartNew();
            var request = RequestTelemetryHelper.StartNewRequest("ProcessSubscribeQueueMessage", DateTimeOffset.UtcNow);
            CallContext.LogicalSetData(CORRELATION_SLOT, request.Id);
            //Thread.SetData(Thread.GetNamedDataSlot(CORRELATION_SLOT), request.Id);
            try
            {
                // Log and delete if this is a "poison" queue message (repeatedly processed
                // and always causes an error that prevents processing from completing).
                // Production applications should move the "poison" message to a "dead message"
                // queue for analysis rather than deleting the message.  
                if (msg.DequeueCount > 5)
                {
                    Trace.TraceError("Deleting poison subscribe message:    message {0}.",
                        msg.AsString, GetRoleInstance());
                    subscribeQueue.DeleteMessage(msg);
                    request.Properties.Add(new KeyValuePair<string, string>("FailureCode", "PoisonMessage"));
                    request.Properties.Add(new KeyValuePair<string, string>("DequeueCount", msg.DequeueCount.ToString()));
                    if (msg.InsertionTime != null)
                    {
                        request.Metrics.Add(new KeyValuePair<string, double>("SubscribeProcessingTimeMs", ((TimeSpan)(DateTimeOffset.Now - msg.InsertionTime)).Milliseconds));
                    }
                    RequestTelemetryHelper.DispatchRequest(request, requestTimer.Elapsed, false);
                    return;
                }
                // Parse message retrieved from queue. Message consists of
                // subscriber GUID and list name.
                // Example:  57ab4c4b-d564-40e3-9a3f-81835b3e102e,contoso1
                var messageParts = msg.AsString.Split(new char[] { ',' });
                var subscriberGUID = messageParts[0];
                var listName = messageParts[1];
                Trace.TraceInformation("ProcessSubscribeQueueMessage start:    subscriber GUID {0} listName {1} Role Instance {2}.",
                    subscriberGUID, listName, GetRoleInstance());
                // Get subscriber info. 
                string filter = TableQuery.CombineFilters(
                    TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, listName),
                    TableOperators.And,
                    TableQuery.GenerateFilterCondition("SubscriberGUID", QueryComparisons.Equal, subscriberGUID));
                var query = new TableQuery<Subscriber>().Where(filter);
                var subscriber = mailingListTable.ExecuteQuery(query).ToList().Single();
                // Get mailing list info.
                var retrieveOperation = TableOperation.Retrieve<MailingList>(subscriber.ListName, "mailinglist");
                var retrievedResult = mailingListTable.Execute(retrieveOperation);
                var mailingList = retrievedResult.Result as MailingList;

                SendSubscribeEmail(subscriberGUID, subscriber, mailingList);

                subscribeQueue.DeleteMessage(msg);

                Trace.TraceInformation("ProcessSubscribeQueueMessage complete: subscriber GUID {0} Role Instance {1}.", subscriberGUID, GetRoleInstance());
                if (msg.InsertionTime != null)
                {
                    request.Metrics.Add(new KeyValuePair<string, double>("SubscribeProcessingTimeMs", ((TimeSpan)(DateTimeOffset.Now - msg.InsertionTime)).Milliseconds));
                }
                RequestTelemetryHelper.DispatchRequest(request, requestTimer.Elapsed, true);
            }
            catch (Exception ex)
            {
                request.Properties.Add(new KeyValuePair<string, string>("FailureCode", "Exception"));
                if (msg.InsertionTime != null)
                {
                    request.Metrics.Add(new KeyValuePair<string, double>("FailedSubscribeProcessingTimeMs", ((TimeSpan)(DateTimeOffset.Now - msg.InsertionTime)).Milliseconds));
                }
                RequestTelemetryHelper.DispatchRequest(request, requestTimer.Elapsed, false);
                throw ex;
            }
            
        }

        private static void SendSubscribeEmail(string subscriberGUID, Subscriber subscriber, MailingList mailingList)
        {
            var email = SendGrid.GetInstance();
            email.From = new MailAddress(mailingList.FromEmailAddress);
            email.AddTo(subscriber.EmailAddress);
            string subscribeURL = RoleEnvironment.GetConfigurationSettingValue("AzureMailServiceURL") +
                "/subscribe?id=" + subscriberGUID + "&listName=" + subscriber.ListName;
            email.Html = String.Format("<p>Click the link below to subscribe to {0}. " +
                "If you don't confirm your subscription, you won't be subscribed to the list.</p>" +
                "<a href=\"{1}\">Confirm Subscription</a>", mailingList.Description, subscribeURL);
            email.Text = String.Format("Copy and paste the following URL into your browser in order to subscribe to {0}. " +
                "If you don't confirm your subscription, you won't be subscribed to the list.\n" +
                "{1}", mailingList.Description, subscribeURL);
            email.Subject = "Subscribe to " + mailingList.Description;
            var credentials = new NetworkCredential(RoleEnvironment.GetConfigurationSettingValue("SendGridUserName"), RoleEnvironment.GetConfigurationSettingValue("SendGridPassword"));
            var transportREST = Web.GetInstance(credentials);
            transportREST.Deliver(email);
        }

        public override void OnStop()
        {
            onStopCalled = true;
            while (returnedFromRunMethod == false)
            {
                System.Threading.Thread.Sleep(1000);
            }
        }

        public override bool OnStart()
        {
            TelemetryConfiguration.Active.InstrumentationKey = RoleEnvironment.GetConfigurationSettingValue("APPINSIGHTS_INSTRUMENTATIONKEY");
            TelemetryConfiguration.Active.TelemetryInitializers.Add(new ItemCorrelationTelemetryInitializer());
            ServicePointManager.DefaultConnectionLimit = Environment.ProcessorCount * 12;

            Trace.TraceInformation("Initializing storage account in worker role B");
            var storageAccount = Microsoft.WindowsAzure.Storage.CloudStorageAccount.Parse(RoleEnvironment.GetConfigurationSettingValue("StorageConnectionString"));

            // Initialize queue storage 
            Trace.TraceInformation("Creating queue client.");
            CloudQueueClient queueClient = storageAccount.CreateCloudQueueClient();
            sendEmailQueue = queueClient.GetQueueReference("azuremailqueue");
            subscribeQueue = queueClient.GetQueueReference("azuremailsubscribequeue");

            // Initialize blob storage
            CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
            blobContainer = blobClient.GetContainerReference("azuremailblobcontainer");

            // Initialize table storage
            var tableClient = storageAccount.CreateCloudTableClient();
            mailingListTable = tableClient.GetTableReference("mailinglist");
            messageTable = tableClient.GetTableReference("message");
            messagearchiveTable = tableClient.GetTableReference("messagearchive");

            Trace.TraceInformation("WorkerB: Creating blob container, queue, tables, if they don't exist.");
            blobContainer.CreateIfNotExists();
            sendEmailQueue.CreateIfNotExists();
            subscribeQueue.CreateIfNotExists();
            this.messageTable.CreateIfNotExists();
            this.mailingListTable.CreateIfNotExists();
            this.messagearchiveTable.CreateIfNotExists();
            
            return base.OnStart();
        }
    }
}
